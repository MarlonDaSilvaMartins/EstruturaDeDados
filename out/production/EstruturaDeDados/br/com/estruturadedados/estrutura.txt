lista  // estrutura de dados do qual um conjunto de dados é acessivel em uma sequencia determinada
          receber dados do banco, lista de um carinho de compras

fila   // estrutura de dados linear do qual o primeiro resultado a entrar é o primeiro a sair(FIFO)
          remoção: remove do topo
          inserção: insere no fim
          pedidos, sistema de fila, caminhoes esperando pela descarga

pilha  // estrutura de dados em que o acesso é restrito ao elemento mais recente da pilha(LIFO),
          push: inserir no topo
          pop: retirar do topo
          top: observar topo
          Mecanismo de fazer/desfazer de editor de texto, navegação entre paginas web

hash   // é uma tabela onde as informalçoes sao armazenadas conforme um numero hash, calculado com base nas proproedades
          da informação

equals // garante que dois objetos sao significativamente iguais, que tenham um valor igual de acordo com suas
          propriedades

list //
queue //
set //
map //

ArrayList //
LinkedList //
 * add(e)      = LinkedList = O(1) | ArrayList = O(n)
 * add(i, e)   = LinkedList = O(n) | ArrayList = O(n) no pior caso, o array será redimensionado e copiado para um novo array
 * remove      = LinkedList possui O(n) e ArrayList possui O(n-index) se remover o ultimo ele mento será O(1)
 * get         = LinkedList = O(n) | ArrayList = O(1)
 * set         = LinkedList = O(n) | ArrayList = O(n)
 * duplicado   = Linkedlist = Permite valores duplicados pois cada valor é guardado em um nodo diferente
                 Arraylist  = Permite valores duplicados pois guarda o objeto da maneira que sao inseridos
 * tam inicial = Linkedlist = sem tamanho inicial | Arraylist = 10 se nao for especificado outro valor na inicializacao
 * tam maximo  = Linkedlist = sem limite | Arraylist = sem limite, quando chega no maximo(10) se expande automaticamente dobrando de tamanho

LinkedHashSet //
HashSet //
TreeSet //
 * add         = LinkedHashSet = O(1) | HashSet = O(1) | TreeSet = O(log n)
 * remove      = LinkedHashSet = O(1) | HashSet = O(1) | TreeSet = O(log n)
 * busca       = LinkedHashSet = O(1) | HashSet = O(1) | TreeSet = O(log n)
 * duplicado   = LinkedHashSet = nao permite | HashSet = nao permite | TreeSet = nao permite
 * ordenacao   = LinkedHashSet = ordem de inserção
                 HashSet = nao mantem ordem
                 TreeSet = ordem ascendente ou ordem do camparador
 * tam inicial = LinkedHashSet = 16 buckets | HashSet = 16 | TreeSet = 16
 * tam maximo  = LinkedHashSet = sem limite | HashSet = sem limite* | TreeSet = sem limite
                 * relativamente ineficiente a partir de 100 milhoes de elemento devido a distribuicao de 32bits do
                 hashcode que comeca a ficar menos aleatorio e aumentando o numero de colisoes

HashMap //
LinkedHashMap //
TreeMap //
 * add         = LinkedHashMap = O(1) | HashMap = O(1) | TreeMap = O(log n)
 * remove      = LinkedHashMap = O(1) | HashMap = O(1) | TreeMap = O(log n)
 * busca       = LinkedHashMap = O(1) | HashMap = O(1) | TreeMap = O(log n)
 * duplicado   = LinkedHashMap = nao contem chaves duplicadas
                 HashMap = nao contem chaves duplicadas
                 TreeMap = nao contem chaves duplicadas
 * ordenacao   = LinkedHashMap = ordem de inserção
                 HashMap = nao mantem ordem
                 TreeMap = ordem ascendente ou ordem do camparador
 * tam inicial = LinkedHashMap = 16 | HashMap = 16 | TreeMap = 16
 * tam maximo  = LinkedHashMap = sem limite | HashMap = sem limite | TreeMap = sem limite

 * Interfaces Funcionais = Interface com apenas um metodo abstrato
        Function  []=
        Consumer  []= contem uma funcao que recebe um argumento e tem um retorno void
        Supplier  []= interface que nao aceita argumentos e retorna um resultado
        Predicate []= contem uma funcao que recebe um argumento e tem um retorno boolean
 * Lambda    = bloco curto de codigo que tem parametros e retorna um valor
 * Generics  =
 * Wildcards =
 * Optional  =
 * Streams   = solução para processar coleções de maneira declarativa
 * API DE DATAS =

 Protocolo HTTP //
 * Request methods =
 * Header          =
 * Body            =
 * Path Variable   =
 * Query Param     =


 Correção = Interface